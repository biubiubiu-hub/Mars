<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>卫星变轨（升轨 / 降轨）</title>

  <style>
    :root { --bg:#0b1020; --panel:#121a33; --text:#e7ebff; --muted:#a9b1d6; --line:#2a3566; }

    html, body { width: 100%; height: 100%; margin: 0; overflow-x: hidden; overflow-y: hidden; }

    body {
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans SC", Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      overscroll-behavior: none;
    }

    .wrap {
      display: grid;
      grid-template-columns: minmax(0, 1fr) 380px;
      gap: 12px;
      padding: 12px;
      box-sizing: border-box;
      height: 100vh;
      width: 100%;
      max-width: 100vw;
    }

    .card {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 12px;
      min-width: 0;
      overflow: hidden;
    }

    #stage {
      width: 100%;
      height: calc(100vh - 24px);
      height: calc(100dvh - 24px);
      border-radius: 12px;
      overflow: hidden;
      position: relative;
      contain: layout paint;

      touch-action: none;
      overscroll-behavior: none;
      user-select: none;
      -webkit-user-select: none;

      background-image: url("../assets/space.jpg");
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      background-color: #000;
    }

    #stage::before{
      content:"";
      position:absolute;
      inset:0;
      background: rgba(0,0,0,0.45);
      z-index: 0;
      pointer-events:none;
    }

    #canvas {
      position: relative;
      z-index: 1;
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none;
    }

    .panel {
      padding: 14px;
      display: flex;
      flex-direction: column;
      gap: 12px;

      height: calc(100vh - 24px);
      height: calc(100dvh - 24px);
      overflow-y: auto;
      overflow-x: hidden;
      -webkit-overflow-scrolling: touch;
    }

    .panel .card { overflow: visible; }

    h1 { font-size: 16px; margin: 0 0 6px 0; }
    .row { display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .row label { font-size: 13px; color: var(--muted); }
    .row .val { font-variant-numeric: tabular-nums; font-size: 13px; }

    input[type="range"] {
      width: 100%;
      height: 34px;
      margin: 2px 0 0;
      background: transparent;
      -webkit-appearance: none;
      appearance: none;
      cursor: pointer;
    }

    input[type="range"]::-webkit-slider-runnable-track {
      height: 8px;
      border-radius: 999px;
      background: rgba(255,255,255,0.22);
      border: 1px solid rgba(42,53,102,0.9);
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      background: rgba(231,235,255,0.95);
      border: 2px solid rgba(24,34,74,1);
      margin-top: -6px;
    }

    input[type="range"]::-moz-range-track {
      height: 8px;
      border-radius: 999px;
      background: rgba(255,255,255,0.22);
      border: 1px solid rgba(42,53,102,0.9);
    }

    input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 999px;
      background: rgba(231,235,255,0.95);
      border: 2px solid rgba(24,34,74,1);
    }

    .btns { display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }

    button {
      padding: 10px 12px; border-radius: 10px; border: 1px solid var(--line);
      background: #18224a; color: var(--text); cursor: pointer; font-weight: 700;
    }
    button:hover { filter: brightness(1.07); }
    button:disabled { opacity: .5; cursor: not-allowed; }

    .hint { font-size: 12px; color: var(--muted); line-height: 1.55; }

    .status {
      padding: 10px 12px; border-radius: 10px; border: 1px solid var(--line);
      background: rgba(255,255,255,0.03); font-size: 13px; line-height: 1.65;
      font-variant-numeric: tabular-nums;
      min-width: 0;
      overflow-wrap: anywhere;
    }

    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .small { font-size: 12px; color: var(--muted); }

    .pill {
      display:inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.06);
      font-size: 12px;
      color: rgba(255,255,255,0.88);
      font-variant-numeric: tabular-nums;
    }

    @media (max-width: 980px) {
      html, body { height: 100%; overflow: hidden; }

      .wrap {
        grid-template-columns: 1fr;
        grid-template-rows: 60vh 1fr;
        height: 100vh;
        align-content: stretch;
      }

      #stage { height: 60vh; height: 60dvh; }

      .card.panel { height: 100%; }
      .panel {
        height: 100%;
        overflow-y: auto;
        overflow-x: hidden;
        -webkit-overflow-scrolling: touch;
      }

      #stage { touch-action: none; }
    }

    @media (max-width: 520px) {
      .wrap { grid-template-rows: 52vh 1fr; }
      #stage { height: 52vh; height: 52dvh; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card">
      <div id="stage">
        <canvas id="canvas"></canvas>
      </div>
    </div>

    <div class="card panel">
      <div>
        <div class="row" style="align-items:flex-start; gap:12px;">
          <div style="flex:1; min-width:0;">
            <h1>卫星变轨（升轨 / 降轨）</h1>
            <div class="hint">
              点火会改变速度 <span class="mono">Δv</span>，从而改变轨道。<br/>
              一次点火通常得到<strong>转移椭圆</strong>；再点一次可把轨道<strong>变圆</strong>。
            </div>
          </div>
          <button id="toMenu" style="white-space:nowrap;">返回菜单</button>
        </div>
      </div>

      <div class="card" style="padding:12px;">
        <div class="row">
          <label>初始轨道高度 h<sub>1</sub>（km）</label>
          <div class="val mono"><span id="h1Val">400</span></div>
        </div>
        <input id="h1" type="range" min="200" max="2000" step="10" value="400" />
        <div class="small">越低：飞得越快；越高：飞得越慢，但轨道更大。</div>
      </div>

      <div class="card" style="padding:12px;">
        <div class="row">
          <label>目标轨道高度 h<sub>2</sub>（km）</label>
          <div class="val mono"><span id="h2Val">800</span></div>
        </div>
        <input id="h2" type="range" min="200" max="2000" step="10" value="800" />
        <div class="row" style="margin-top:8px;">
          <label>快速操作</label>
          <button id="swap">交换（h1 ↔ h2）</button>
        </div>
        <div class="small">升轨：h2 &gt; h1；降轨：h2 &lt; h1。</div>
      </div>

      <div class="card" style="padding:12px;">
        <div class="row">
          <label>动画速度</label>
          <div class="val mono"><span id="spdVal">1.0</span>x</div>
        </div>
        <input id="spd" type="range" min="0.5" max="3.0" step="0.1" value="1.0" />
        <div class="small">只影响演示速度，不改变计算结果。</div>
      </div>

      <div class="btns">
        <button id="run">运行（变轨）</button>
        <button id="reset">复位</button>
      </div>

      <div class="btns">
        <button id="preset1">示例：300 → 800 km</button>
        <button id="preset2">示例：800 → 300 km</button>
      </div>

      <div class="status" id="status">
        <div class="row" style="margin-bottom:6px;">
          <div><b>实时计算</b></div>
          <div class="pill" id="modePill">—</div>
        </div>
        <div>第一次点火：<span class="mono" id="burn1Text">—</span></div>
        <div>第二次点火：<span class="mono" id="burn2Text">—</span></div>
        <div>总 Δv：<span class="mono" id="dvText">—</span></div>
        <div>转移时间（半圈）：<span class="mono" id="ttrText">—</span></div>
        <div>结论：<span class="mono" id="resText">未运行</span></div>
        <div class="small">简化模型：地球引力两体、瞬时点火、忽略阻力与摄动。</div>
      </div>

      <div class="hint">
        观察重点：<br/>
        ① 第一次点火后：轨道变成椭圆——你点火的这一侧仍在原高度；另一侧被抬高/压低。<br/>
        ② 半圈到达另一侧再点火：把椭圆“抹圆”，进入目标圆轨道。
      </div>
    </div>
  </div>

  <script>
    // =========================
    // 0) DOM
    // =========================
    const el = id => document.getElementById(id);

    const canvas = el('canvas');
    const ctx = canvas.getContext('2d');

    // 地球贴图（固定像素大小，不随轨道缩放变化）
    const earthImg = new Image();
    earthImg.decoding = 'async';
    earthImg.src = '../assets/earth.png';
    earthImg.onload = () => { draw(); };

    // 卫星贴图（用于替换三角形）
    const satImg = new Image();
    satImg.decoding = 'async';
    satImg.src = '../assets/sat.png';
    satImg.onload = () => { draw(); };

    function earthRadiusPx(w, h) {
      // 地球稍微放大一些：减少“地球到轨道之间”的空白（仍然不随轨道高度缩放变化）
      return clamp(Math.min(w, h) * 0.14, 44, 92);
    }

    function drawEarthImage(cx, cy, w, h) {
      const r = earthRadiusPx(w, h);
      const d = r * 2;

      // ✅ 使用 earth.png（固定像素大小，不随轨道缩放变化）
      if (earthImg && earthImg.complete && (earthImg.naturalWidth || earthImg.width) > 0) {
        ctx.save();
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, TAU);
        ctx.clip();

        // 为了避免贴图边缘自带的透明/暗边造成“光晕圈”，裁掉源图四周一点点再绘制
        const iw = earthImg.naturalWidth || earthImg.width;
        const ih = earthImg.naturalHeight || earthImg.height;
        const pad = 0.045; // 4.5%（若仍有边圈可调到 0.06；太大则会裁掉云层边缘）
        const sx = iw * pad;
        const sy = ih * pad;
        const sw = iw * (1 - pad * 2);
        const sh = ih * (1 - pad * 2);

        ctx.drawImage(earthImg, sx, sy, sw, sh, cx - r, cy - r, d, d);
        ctx.restore();

        // 轻微压暗边缘（在圆内，不产生外圈）
        ctx.save();
        const rim = ctx.createRadialGradient(cx, cy, r * 0.10, cx, cy, r);
        rim.addColorStop(0, 'rgba(0,0,0,0.00)');
        rim.addColorStop(1, 'rgba(0,0,0,0.14)');
        ctx.fillStyle = rim;
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, TAU);
        ctx.fill();
        ctx.restore();

        return;
      }

      // 兜底：图片未加载时，画一个简化圆形地球
      ctx.save();
      ctx.fillStyle = 'rgba(40,110,210,0.95)';
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, TAU);
      ctx.fill();
      ctx.restore();
    }

    const h1El = el('h1');
    const h2El = el('h2');
    const spdEl = el('spd');

    const h1Val = el('h1Val');
    const h2Val = el('h2Val');
    const spdVal = el('spdVal');

    const runBtn = el('run');
    const resetBtn = el('reset');
    const swapBtn = el('swap');
    const preset1Btn = el('preset1');
    const preset2Btn = el('preset2');
    const toMenuBtn = el('toMenu');

    const modePill = el('modePill');
    const burn1Text = el('burn1Text');
    const burn2Text = el('burn2Text');
    const dvText = el('dvText');
    const ttrText = el('ttrText');
    const resText = el('resText');

    // 禁止在画布区域滚动（和其它场景保持一致）
    const stageEl = el('stage');
    if (stageEl) {
      stageEl.addEventListener('wheel', (e) => { e.preventDefault(); }, { passive: false });
      stageEl.addEventListener('touchmove', (e) => { e.preventDefault(); }, { passive: false });
    }

    // =========================
    // 1) 常量与轨道计算（单位：km, s）
    // =========================
    const MU = 398600.4418; // 地球标准引力参数 km^3/s^2
    const RE = 6371.0;      // 地球平均半径 km
    const TAU = Math.PI * 2;

    function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }

    function roundRect(ctx, x, y, w, h, r) {
      const rr = Math.max(0, Math.min(r, Math.min(w, h) / 2));
      ctx.beginPath();
      ctx.moveTo(x + rr, y);
      ctx.arcTo(x + w, y, x + w, y + h, rr);
      ctx.arcTo(x + w, y + h, x, y + h, rr);
      ctx.arcTo(x, y + h, x, y, rr);
      ctx.arcTo(x, y, x + w, y, rr);
      ctx.closePath();
    }

    function calcHohmann(r1, r2) {
      // r1 -> r2 的霍曼两冲量（允许 r2<r1）
      const a = (r1 + r2) / 2;

      const v1 = Math.sqrt(MU / r1);
      const v2 = Math.sqrt(MU / r2);

      // vis-viva on transfer ellipse
      const vT1 = Math.sqrt(MU * (2 / r1 - 1 / a));
      const vT2 = Math.sqrt(MU * (2 / r2 - 1 / a));

      const dv1 = vT1 - v1;
      const dv2 = v2 - vT2;

      const ttr = Math.PI * Math.sqrt(a*a*a / MU); // half period

      return { a, v1, v2, vT1, vT2, dv1, dv2, dv: (Math.abs(dv1) + Math.abs(dv2)), ttr };
    }

    function fmtSigned(x, digits=3) {
      const s = x.toFixed(digits);
      return (x >= 0 ? '+' : '') + s;
    }

    function fmtTimeSec(s) {
      if (!Number.isFinite(s)) return '—';
      if (s < 120) return `${s.toFixed(0)} s`;
      const m = Math.floor(s / 60);
      const r = s - m*60;
      if (m < 60) return `${m} min ${r.toFixed(0)} s`;
      const h = Math.floor(m / 60);
      const mm = m - h*60;
      return `${h} h ${mm} min`;
    }

    // =========================
    // 2) Canvas
    // =========================
    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.width = Math.round(rect.width * dpr);
      canvas.height = Math.round(rect.height * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    window.addEventListener('resize', () => { resizeCanvas(); draw(); });

    function withShadow(fn) {
      ctx.save();
      ctx.shadowColor = 'rgba(0,0,0,0.35)';
      ctx.shadowBlur = 10;
      fn();
      ctx.restore();
    }


    function drawOrbitCircle(cx, cy, rPx, color, width=2, dash=null) {
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = width;
      if (dash) ctx.setLineDash(dash);
      ctx.beginPath();
      ctx.arc(cx, cy, rPx, 0, TAU);
      ctx.stroke();
      ctx.restore();
    }

    function transferR(theta, r1, r2) {
      const a = (r1 + r2) / 2;
      const e = (r2 - r1) / (r2 + r1); // can be negative
      const p = a * (1 - e*e);
      return p / (1 + e * Math.cos(theta));
    }

    function drawTransferEllipse(cx, cy, rToPx, r1, r2, color, width=3, thetaMax=Math.PI, alpha=0.8) {
      ctx.save();
      ctx.strokeStyle = color;
      ctx.globalAlpha = alpha;
      ctx.lineWidth = width;
      ctx.beginPath();
      const N = 360;
      for (let i = 0; i <= N; i++) {
        const th = (i / N) * thetaMax;
        const rKm = transferR(th, r1, r2);
        const rPx = rToPx(rKm);
        const x = cx + (rPx * Math.cos(th));
        const y = cy + (rPx * Math.sin(th));
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
      ctx.restore();
    }

    function drawSat(x, y, angRad, flame=0, burnDir=0) {
      // 卫星：优先用图片 sat.png，并按速度方向旋转；图片未加载则用三角形兜底
      // burnDir: +1=顺行加速（加速），-1=逆行减速（减速），0=无点火
      const hasImg = satImg && satImg.complete && (satImg.naturalWidth || satImg.width) > 0;

      const viewMin = Math.min(canvas.getBoundingClientRect().width, canvas.getBoundingClientRect().height);
      const icon = clamp(viewMin * 0.060, 32, 62); // ✅ 更大：更醒目

      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angRad);

      // =========
      // 点火视觉：喷焰 + “加速/减速”提示（在图上能一眼看出）
      // =========
      if (flame > 0 && burnDir !== 0) {
        const a = 0.92 * flame;

        // 1) 轻微环形光晕（加速=绿、减速=红）
        ctx.save();
        ctx.globalAlpha = 0.55 * flame;
        ctx.strokeStyle = burnDir > 0 ? 'rgba(120,255,180,0.85)' : 'rgba(255,120,120,0.85)';
        ctx.lineWidth = Math.max(2, icon * 0.10);
        ctx.beginPath();
        ctx.arc(0, 0, icon * 0.72, 0, TAU);
        ctx.stroke();
        ctx.restore();

        // 2) 喷焰（统一朝“后方”，保证观感稳定；通过颜色+箭头表达加速/减速）
        ctx.save();
        ctx.globalAlpha = a;
        ctx.fillStyle = burnDir > 0 ? 'rgba(255,170,90,0.92)' : 'rgba(255,120,120,0.92)';
        ctx.beginPath();
        ctx.moveTo(-icon * 0.58, 0);
        ctx.lineTo(-icon * 0.98, -icon * 0.24);
        ctx.lineTo(-icon * 1.25, 0);
        ctx.lineTo(-icon * 0.98,  icon * 0.24);
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        // 3) 方向箭头 + 标签（更直观）
        //    方向箭头跟随卫星旋转；文字标签保持屏幕正向（不旋转），并在右半屏放到下方
        ctx.save();
        ctx.globalAlpha = a;
        const arrowColor = burnDir > 0 ? 'rgba(120,255,180,0.95)' : 'rgba(255,120,120,0.95)';
        ctx.strokeStyle = arrowColor;
        ctx.fillStyle = arrowColor;
        ctx.lineWidth = Math.max(2, icon * 0.08);
        ctx.lineCap = 'round';

        // 箭头放在卫星上方一点，避免遮挡图标
        const ay = -icon * 0.90;
        const L = icon * 0.85;
        const sgn = (burnDir > 0) ? +1 : -1;

        // 主线
        ctx.beginPath();
        ctx.moveTo(-sgn * (L * 0.55), ay);
        ctx.lineTo( sgn * (L * 0.55), ay);
        ctx.stroke();

        // 箭头头
        ctx.beginPath();
        ctx.moveTo( sgn * (L * 0.55), ay);
        ctx.lineTo( sgn * (L * 0.30), ay - icon * 0.18);
        ctx.lineTo( sgn * (L * 0.30), ay + icon * 0.18);
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        // 文本 pill（加速/减速）——保持文字始终正向（不跟随旋转）
        ctx.save();
        ctx.rotate(-angRad);

        const label = burnDir > 0 ? '加速' : '减速';
        const fontPx = Math.round(clamp(icon * 0.42, 14, 18));
        ctx.font = `800 ${fontPx}px system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans SC", Arial, sans-serif`;

        // ✅ padding 与字体一起放大，框框会跟着变
        const padX = Math.round(clamp(icon * 0.20, 10, 16));
        const padY = Math.round(clamp(icon * 0.16, 7, 12));

        const m = ctx.measureText(label);
        const tw = m.width;
        const ascent  = (m.actualBoundingBoxAscent  != null) ? m.actualBoundingBoxAscent  : fontPx * 0.82;
        const descent = (m.actualBoundingBoxDescent != null) ? m.actualBoundingBoxDescent : fontPx * 0.24;

        // ✅ 右半屏：把提示放到卫星下方；左半屏：放到上方
        const viewW = canvas.getBoundingClientRect().width;
        const isRightSide = x > viewW * 0.5;
        const cyLabel = isRightSide ? (icon * 1.05) : (-icon * 1.35);

        const bw = Math.round(tw + padX * 2);
        const bh = Math.round(ascent + descent + padY * 2);

        const bx = -bw / 2;
        const by = cyLabel - bh / 2;
        const br = Math.round(clamp(icon * 0.18, 10, 14));

        ctx.save();
        ctx.globalAlpha = 0.55 * flame;
        ctx.fillStyle = 'rgba(0,0,0,0.45)';
        roundRect(ctx, bx, by, bw, bh, br);
        ctx.fill();
        ctx.restore();

        ctx.save();
        ctx.globalAlpha = 0.95 * flame;
        ctx.strokeStyle = burnDir > 0 ? 'rgba(120,255,180,0.45)' : 'rgba(255,120,120,0.45)';
        ctx.lineWidth = 1.5;
        roundRect(ctx, bx, by, bw, bh, br);
        ctx.stroke();
        ctx.restore();

        ctx.save();
        ctx.globalAlpha = 0.98 * flame;
        ctx.fillStyle = 'rgba(255,255,255,0.95)';
        ctx.fillText(label, -tw / 2, by + padY + ascent);
        ctx.restore();

        ctx.restore();
      }

      // =========
      // 卫星本体
      // =========
      if (hasImg) {
        // sat.png 默认朝向：假设“朝右”为前进方向。
        // 如果你的 sat.png 是朝上/朝左，可把这个偏置改成 -90 / 180 等。
        const OFFSET_DEG = 0;
        ctx.rotate(OFFSET_DEG * Math.PI / 180);

        ctx.imageSmoothingEnabled = true;
        ctx.drawImage(satImg, -icon/2, -icon/2, icon, icon);
      } else {
        // 兜底：机身三角形
        ctx.fillStyle = 'rgba(255,255,255,0.92)';
        ctx.beginPath();
        ctx.moveTo(icon * 0.45, 0);
        ctx.lineTo(-icon * 0.22, -icon * 0.22);
        ctx.lineTo(-icon * 0.08, 0);
        ctx.lineTo(-icon * 0.22, icon * 0.22);
        ctx.closePath();
        ctx.fill();
      }

      ctx.restore();
    }

    function drawLabel(text, x, y, dx=10, dy=-10) {
      const w = canvas.getBoundingClientRect().width;
      const h = canvas.getBoundingClientRect().height;
      const pad = 10; // 与边缘保持一点距离

      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.88)';
      ctx.font = '12px system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans SC", Arial, sans-serif';

      const tw = ctx.measureText(text).width;

      // 默认放在 (x+dx, y+dy)，但如果会被裁切则自动翻到另一侧
      let tx = x + dx;
      let ty = y + dy;

      // 右侧被裁：放到点的左边
      if (tx + tw > w - pad) tx = x - tw - pad;
      // 左侧被裁：贴到左边界
      if (tx < pad) tx = pad;

      // 上方被裁：放到点的下方
      if (ty < pad) ty = y + Math.abs(dy);
      // 下方被裁：放到点的上方
      if (ty > h - pad) ty = y - pad;

      ctx.fillText(text, tx, ty);
      ctx.restore();
    }

    // =========================
    // 3) 状态与动画
    // =========================
    let h1 = Number(h1El.value);
    let h2 = Number(h2El.value);
    let speed = Number(spdEl.value);

    let running = false;
    let t = 0;
    let lastTs = null;

    // 分段动画时间（秒）
    const SEG = {
      pre: 1.5,      // 初始圆轨道飞一小段（稍微更从容）
      burn: 0.95,    // 点火提示更久：看得清“加速/减速”
      transfer: 5.2, // 转移半圈更慢一点：更好观察
      post: 1.5,     // 进入目标圆轨道后的第一小段
      tail: 2.4      // ✅ 变轨完成后再多飞一会儿，不要立刻停止
    };

    function setButtons() {
      const dis = running;
      runBtn.disabled = dis;
      resetBtn.disabled = false;
      swapBtn.disabled = dis;
      preset1Btn.disabled = dis;
      preset2Btn.disabled = dis;
      h1El.disabled = dis;
      h2El.disabled = dis;
      spdEl.disabled = dis;
    }

    function syncUI() {
      h1 = Number(h1El.value);
      h2 = Number(h2El.value);
      speed = Number(spdEl.value);

      h1Val.textContent = String(h1);
      h2Val.textContent = String(h2);
      spdVal.textContent = speed.toFixed(1);

      updateStatus(false);
      draw();
    }

    function updateStatus(ran) {
      const r1 = RE + h1;
      const r2 = RE + h2;

      if (Math.abs(h2 - h1) < 1e-9) {
        modePill.textContent = '不变轨';
        burn1Text.textContent = '—';
        burn2Text.textContent = '—';
        dvText.textContent = '0';
        ttrText.textContent = '—';
        if (!ran) resText.textContent = '未运行';
        return;
      }

      const info = calcHohmann(r1, r2);
      const up = (h2 > h1);

      modePill.textContent = up ? '升轨' : '降轨';

      const dir1 = (info.dv1 >= 0) ? '顺行加速' : '逆行减速';
      const dir2 = (info.dv2 >= 0) ? '顺行加速' : '逆行减速';

      burn1Text.textContent = `${dir1}  Δv1=${fmtSigned(info.dv1, 3)} km/s`;
      burn2Text.textContent = `${dir2}  Δv2=${fmtSigned(info.dv2, 3)} km/s`;
      dvText.textContent = `${info.dv.toFixed(3)} km/s`;
      ttrText.textContent = fmtTimeSec(info.ttr);

      if (!ran) resText.textContent = '未运行';
    }

    function resetSim() {
      running = false;
      t = 0;
      lastTs = null;
      setButtons();
      updateStatus(false);
      resText.textContent = '未运行';
      draw();
    }

    function run() {
      if (running) return;
      if (Math.abs(h2 - h1) < 1e-9) {
        resText.textContent = 'h1 与 h2 相同：无需变轨';
        draw();
        return;
      }
      resetSim();
      running = true;
      setButtons();
      updateStatus(true);
      resText.textContent = '运行中…（点火阶段会更慢，便于观察提示）';
      lastTs = null;
      requestAnimationFrame(step);
    }

    function step(ts) {
      if (!running) return;
      if (lastTs == null) lastTs = ts;
      const dt = (ts - lastTs) / 1000;
      lastTs = ts;

      t += dt * speed;

      const total = SEG.pre + SEG.burn + SEG.transfer + SEG.burn + SEG.post + SEG.tail;
      if (t >= total) {
        t = total;
        running = false;
        setButtons();
        resText.textContent = '✅ 已进入目标轨道（演示结束）';
        draw();
        return;
      }

      draw();
      requestAnimationFrame(step);
    }

    // =========================
    // 4) 绘制
    // =========================
    function draw() {
      const w = canvas.getBoundingClientRect().width;
      const h = canvas.getBoundingClientRect().height;
      ctx.clearRect(0, 0, w, h);

      const cx = w / 2;
      const cy = h / 2;

      const r1 = RE + h1;
      const r2 = RE + h2;
      const rMax = Math.max(r1, r2);

      // 点火方向：dv>0 顺行加速；dv<0 逆行减速
      const info = calcHohmann(r1, r2);
      const burnDir1 = (info.dv1 >= 0) ? +1 : -1;
      const burnDir2 = (info.dv2 >= 0) ? +1 : -1;

      const earthPx = earthRadiusPx(w, h);

      // ✅ 视觉比例：把“高度差”放大，让两条轨道不会挤在一起
      // 用滑条最大高度作为基准（2000km），保证比例在整个范围内稳定
      const ALT_MAX = Number(h1El.max || 2000);

      // 关键：外圈半径必须 <= 画布可容纳的最大半径，否则会出画面
      const EDGE_PAD = 16; // 给轨道与文字留一点安全边距
      const OUTER_TARGET = Math.max(60, Math.min(cx, cy) - EDGE_PAD); // 最大可用半径（像素）

      // 每 km 对应多少 px（下限防极端）
      const altToPx = Math.max(0.02, (OUTER_TARGET - earthPx) / ALT_MAX);

      // 半径映射：r(km)=RE+h  ->  r(px)=earthPx + h*altToPx
      const offset = earthPx - RE * altToPx;
      const rToPx = (rKm) => rKm * altToPx + offset;

      const r1Px = rToPx(r1);
      const r2Px = rToPx(r2);
      // const rePx = rToPx(RE);

      // 目标/初始圆轨道
      drawOrbitCircle(cx, cy, r1Px, 'rgba(120,180,255,0.55)', 2);
      drawOrbitCircle(cx, cy, r2Px, 'rgba(255,190,140,0.45)', 2);

      // 转移椭圆（淡全圈 + 强调半圈）
      drawTransferEllipse(cx, cy, rToPx, r1, r2, 'rgba(199,249,204,0.22)', 2, Math.PI*2, 0.65);
      drawTransferEllipse(cx, cy, rToPx, r1, r2, 'rgba(199,249,204,0.90)', 3, Math.PI, 0.95);

      // 地球
      drawEarthImage(cx, cy, w, h);

      // 标注（简单）
      const p1x = cx + r1Px;
      const p1y = cy;
      const p2x = cx - r2Px;
      const p2y = cy;

      ctx.save();
      ctx.globalAlpha = 0.9;
      drawLabel(`h1=${h1} km`, p1x, p1y, 10, -10);
      drawLabel(`h2=${h2} km`, p2x, p2y, 10, -10);
      ctx.restore();

      // 画卫星位置（分段）
      const total = SEG.pre + SEG.burn + SEG.transfer + SEG.burn + SEG.post + SEG.tail;
      const tt = clamp(t, 0, total);

      const t0 = SEG.pre;
      const t1 = t0 + SEG.burn;
      const t2 = t1 + SEG.transfer;
      const t3 = t2 + SEG.burn;
      const t4 = t3 + SEG.post;

      let satX = p1x, satY = p1y, satAng = 0;
      let flame = 0;
      let burnDir = 0; // +1 加速 / -1 减速 / 0 无点火

      // 初始圆轨道：从 angle=-0.35π 到 0
      if (tt <= t0) {
        const p = tt / t0;
        const ang = (-0.35*Math.PI) + p * (0.35*Math.PI);
        satX = cx + r1Px * Math.cos(ang);
        satY = cy + r1Px * Math.sin(ang);
        satAng = ang + Math.PI/2;
      }
      // 点火1：固定在 (r1,0)
      else if (tt <= t1) {
        satX = p1x; satY = p1y;
        satAng = Math.PI/2;
        const p = (tt - t0) / SEG.burn;
        flame = Math.sin(p * Math.PI);
        burnDir = burnDir1;
      }
      // 转移半圈：theta 0 -> π
      else if (tt <= t2) {
        const p = (tt - t1) / SEG.transfer;
        const th = p * Math.PI;
        const rr = transferR(th, r1, r2);
        const rrPx = rToPx(rr);
        satX = cx + (rrPx * Math.cos(th));
        satY = cy + (rrPx * Math.sin(th));

        // 用有限差分近似切线方向
        const eps = 0.002;
        const th2 = Math.min(Math.PI, th + eps);
        const rr2 = transferR(th2, r1, r2);
        const rr2Px = rToPx(rr2);
        const x2 = cx + (rr2Px * Math.cos(th2));
        const y2 = cy + (rr2Px * Math.sin(th2));
        satAng = Math.atan2(y2 - satY, x2 - satX);
      }
      // 点火2：固定在 (−r2,0)
      else if (tt <= t3) {
        satX = p2x; satY = p2y;
        satAng = -Math.PI/2;
        const p = (tt - t2) / SEG.burn;
        flame = Math.sin(p * Math.PI);
        burnDir = burnDir2;
      }
      // 目标圆轨道：先从 angle=π 到 π+0.35π
      else if (tt <= t4) {
        const p = (tt - t3) / SEG.post;
        const ang = Math.PI + p * (0.35*Math.PI);
        satX = cx + r2Px * Math.cos(ang);
        satY = cy + r2Px * Math.sin(ang);
        satAng = ang + Math.PI/2;
      }
      // ✅ 变轨完成后再多运行一点点：继续沿目标圆轨道前进
      else {
        const p = (tt - t4) / SEG.tail;
        const ang = Math.PI + (0.35*Math.PI) + p * (0.45*Math.PI);
        satX = cx + r2Px * Math.cos(ang);
        satY = cy + r2Px * Math.sin(ang);
        satAng = ang + Math.PI/2;
      }

      // 点火方向（顺行/逆行）用 flame 的左右来暗示（可读性更强）：
      // 顺行：喷焰朝后（卫星朝前）。逆行：卫星朝后（喷焰仍在后）。
      // 这里不做复杂姿态切换，只保持沿切线朝向。
      drawSat(satX, satY, satAng, flame, burnDir);

      // 小 HUD
      ctx.save();
      const hud = (Math.abs(h2-h1) < 1e-9) ? '无需变轨' : (h2>h1 ? '升轨：近地点加速 → 远地点抬高' : '降轨：远地点减速 → 近地点降低');
      ctx.font = '13px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
      const tw = ctx.measureText(hud).width;
      const x = 18;
      const y = 26;
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.fillRect(x - 8, y - 16, tw + 16, 22);
      ctx.fillStyle = 'rgba(255,255,255,0.90)';
      ctx.fillText(hud, x, y);
      ctx.restore();
    }

    // =========================
    // 5) 事件
    // =========================
    [h1El, h2El, spdEl].forEach(inp => {
      inp.addEventListener('input', () => {
        if (running) return;
        syncUI();
      });
    });

    swapBtn.addEventListener('click', () => {
      if (running) return;
      const a = h1El.value;
      h1El.value = h2El.value;
      h2El.value = a;
      syncUI();
      resText.textContent = '未运行';
    });

    preset1Btn.addEventListener('click', () => {
      if (running) return;
      h1El.value = '300';
      h2El.value = '800';
      syncUI();
      resText.textContent = '未运行';
    });

    preset2Btn.addEventListener('click', () => {
      if (running) return;
      h1El.value = '800';
      h2El.value = '300';
      syncUI();
      resText.textContent = '未运行';
    });

    runBtn.addEventListener('click', run);
    resetBtn.addEventListener('click', resetSim);

    toMenuBtn.addEventListener('click', () => {
      window.location.href = '../index.html';
    });

    // =========================
    // 6) 初始化
    // =========================
    resizeCanvas();
    syncUI();
    resetSim();
  </script>
</body>
</html>