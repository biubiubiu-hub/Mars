<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>火箭发射（高度-时间）</title>

  <style>
    :root { --bg:#0b1020; --panel:#121a33; --text:#e7ebff; --muted:#a9b1d6; --line:#2a3566; }

    /* 默认：桌面用 100vh 固定布局，不让页面整体滚动（滚动由右侧面板内部承担） */
    html, body { width: 100%; height: 100%; margin: 0; overflow-x: hidden; overflow-y: hidden; }

    body {
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans SC", Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      overscroll-behavior: none;
    }

    .wrap {
      display: grid;
      grid-template-columns: minmax(0, 1fr) 380px;
      gap: 12px;
      padding: 12px;
      box-sizing: border-box;
      height: 100vh;
      width: 100%;
      max-width: 100vw;
    }

    .card {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 12px;
      min-width: 0;
      overflow: hidden;
    }

    #stage {
      width: 100%;
      height: calc(100vh - 24px);
      height: calc(100dvh - 24px);
      border-radius: 12px;
      overflow: hidden;
      position: relative;
      contain: layout paint;

      /* 禁止在左侧画布区域发生页面滚动/回弹/手势拖动 */
      touch-action: none;
      overscroll-behavior: none;
      user-select: none;
      -webkit-user-select: none;

      background-image: url("../assets/space.jpg");
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      background-color: #000;
    }

    #stage::before{
      content:"";
      position:absolute;
      inset:0;
      background: rgba(0,0,0,0.45);
      z-index: 0;
      pointer-events:none;
    }

    #canvas {
      position: relative;
      z-index: 1;
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none;
    }

    .panel {
      padding: 14px;
      display: flex;
      flex-direction: column;
      gap: 12px;

      /* 右侧内容多时：允许面板自身滚动，不要被 .card 的 overflow:hidden 裁掉 */
      height: calc(100vh - 24px);
      height: calc(100dvh - 24px);
      overflow-y: auto;
      overflow-x: hidden;
      -webkit-overflow-scrolling: touch;
    }

    /* 右侧参数卡片允许滑块圆点“溢出”，避免被 card 的 overflow 裁切造成遮挡 */
    .panel .card { overflow: visible; }

    h1 { font-size: 16px; margin: 0 0 6px 0; }
    .row { display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .row label { font-size: 13px; color: var(--muted); }
    .row .val { font-variant-numeric: tabular-nums; font-size: 13px; }

    /* 让滑块更“好点/好拖”（尤其是触控板/触屏） */
    input[type="range"] {
      width: 100%;
      height: 34px;            /* 增大可操作区域 */
      margin: 2px 0 0;
      background: transparent;
      -webkit-appearance: none;
      appearance: none;
      cursor: pointer;
    }

    input[type="range"]::-webkit-slider-runnable-track {
      height: 8px;
      border-radius: 999px;
      background: rgba(255,255,255,0.22);
      border: 1px solid rgba(42,53,102,0.9);
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      background: rgba(231,235,255,0.95);
      border: 2px solid rgba(24,34,74,1);
      margin-top: -6px; /* 让圆点垂直居中到轨道 */
    }

    input[type="range"]::-moz-range-track {
      height: 8px;
      border-radius: 999px;
      background: rgba(255,255,255,0.22);
      border: 1px solid rgba(42,53,102,0.9);
    }

    input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 999px;
      background: rgba(231,235,255,0.95);
      border: 2px solid rgba(24,34,74,1);
    }

    .btns { display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }

    button {
      padding: 10px 12px; border-radius: 10px; border: 1px solid var(--line);
      background: #18224a; color: var(--text); cursor: pointer; font-weight: 600;
    }
    button:hover { filter: brightness(1.07); }
    button:disabled { opacity: .5; cursor: not-allowed; }

    .hint { font-size: 12px; color: var(--muted); line-height: 1.55; }

    /* 底部说明离边缘太近：给最后一段 hint 增加一点下内边距 */
    .panel > .hint:last-child { padding-bottom: 10px; }

    .status {
      padding: 10px 12px; border-radius: 10px; border: 1px solid var(--line);
      background: rgba(255,255,255,0.03); font-size: 13px; line-height: 1.65;
      font-variant-numeric: tabular-nums;
      min-width: 0;
      overflow-wrap: anywhere;
    }

    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .small { font-size: 12px; color: var(--muted); }

    @media (max-width: 980px) {
      .wrap { grid-template-columns: 1fr; grid-template-rows: 60vh auto; height: auto; align-content: start; }
      .panel { height: auto; overflow: visible; }
      #stage { height: 60vh; }
      /* 移动端（上下堆叠）需要页面可滚动，否则无法从画布滑到下面的面板 */
      html, body { height: auto; overflow-y: auto; }
      /* 允许在画布区域做“竖向滑动”触发页面滚动 */
      #stage { touch-action: pan-y; }
    }

    @media (max-width: 520px) {
      .wrap { grid-template-rows: 52vh auto; }
      #stage { height: 52vh; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card">
      <div id="stage">
        <canvas id="canvas"></canvas>
      </div>
    </div>

    <div class="card panel">
      <div>
        <div class="row" style="align-items:flex-start; gap:12px;">
          <div style="flex:1; min-width:0;">
            <h1>火箭发射（高度–时间）</h1>
            <div class="hint">
              用二次函数 <span class="mono">h(t)=at²+bt+c</span> 描述“高度随时间变化”。<br/>
              <b>上升段</b>画实线，<b>下降段</b>画虚线（以顶点为分界）。
            </div>
          </div>
          <button id="toMenu" style="white-space:nowrap;">返回菜单</button>
        </div>
      </div>

      <div class="card" style="padding:12px;">
        <div class="row">
          <label>a（开口向下：a&lt;0）</label>
          <div class="val mono"><span id="aVal">-1.20</span></div>
        </div>
        <input id="a" type="range" min="-3.00" max="-0.30" step="0.05" value="-1.20" />
        <div class="small">|a| 越大：开口越“窄”（弯得更明显），顶点更早、最高点更低，下降更陡。</div>
      </div>

      <div class="card" style="padding:12px;">
        <div class="row">
          <label>b（起飞“上升趋势”）</label>
          <div class="val mono"><span id="bVal">16.0</span></div>
        </div>
        <input id="b" type="range" min="2" max="28" step="0.5" value="16" />
        <div class="small">b 越大：更快上升，顶点通常更高也更晚。</div>
      </div>

      <div class="card" style="padding:12px;">
        <div class="row">
          <label>c（t=0 的初始高度）</label>
          <div class="val mono"><span id="cVal">6.0</span></div>
        </div>
        <input id="c" type="range" min="0" max="30" step="0.5" value="6" />
        <div class="small">c 是截距：<span class="mono">h(0)=c</span>。</div>
      </div>

      <div class="card" style="padding:12px;">
        <div class="row">
          <label>目标高度 H（水平线）</label>
          <div class="val mono"><span id="hVal">50</span></div>
        </div>
        <input id="H" type="range" min="10" max="120" step="1" value="50" />
        <div class="small">解 <span class="mono">h(t)=H</span> 看是否能到达目标高度。</div>
      </div>

      <div class="card" style="padding:12px;">
        <div class="row">
          <label>动画速度</label>
          <div class="val mono"><span id="spdVal">1.0</span>x</div>
        </div>
        <input id="spd" type="range" min="0.5" max="2.5" step="0.1" value="1.0" />
      </div>

      <div class="btns">
        <button id="run">运行（发射）</button>
        <button id="reset">复位</button>
      </div>

      <div class="btns">
        <button id="autoReach">一键可达目标（调 b）</button>
        <button id="toggleGrid">网格：开</button>
      </div>


      <div class="status" id="status">
        <div><b>实时计算</b></div>
        <div>函数：<span class="mono" id="fnText">—</span></div>
        <div>顶点（最高点）：<span class="mono" id="vText">—</span></div>
        <div>能否到达 H：<span class="mono" id="deltaText">—</span></div>
        <div>到达 H 的时刻：<span class="mono" id="hitText">—</span></div>
        <div>高于 H 的时长：<span class="mono" id="aboveText">—</span></div>
        <div>结论：<span class="mono" id="resText">未运行</span></div>
        <div class="small">判别式：Δ = b² − 4a(c−H)，对应方程 at²+bt+(c−H)=0。</div>
      </div>

      <div class="hint">
        课堂用法：<br/>
        ① 先观察顶点：<span class="mono">t_v=-b/(2a)</span>；② 再看 Δ 判断能否到达 H；③ 看两次到达时刻（上升/下降）。<br/>
        图上：上升段实线，下降段虚线（顶点之后回落）。
      </div>
    </div>
  </div>

  <script>
    // =========================
    // 0) DOM
    // =========================
    const el = id => document.getElementById(id);

    const stageEl = el('stage');

    const aEl = el('a');
    const bEl = el('b');
    const cEl = el('c');
    const HEl = el('H');
    const spdEl = el('spd');

    const aVal = el('aVal');
    const bVal = el('bVal');
    const cVal = el('cVal');
    const hVal = el('hVal');
    const spdVal = el('spdVal');

    const fnText = el('fnText');
    const vText = el('vText');
    const deltaText = el('deltaText');
    const hitText = el('hitText');
    const aboveText = el('aboveText');
    const resText = el('resText');

    const runBtn = el('run');
    const resetBtn = el('reset');
    const autoReachBtn = el('autoReach');
    const toggleGridBtn = el('toggleGrid');
    const toMenuBtn = el('toMenu');

    // 禁止在左侧画布区域滚动（桌面：防止触控板/回弹让画面“漂移”）
    // 但移动端（窄屏上下堆叠）需要允许在画布区域竖向滑动来滚到下面的面板。
    const isStackedLayout = () => (window.matchMedia && window.matchMedia('(max-width: 980px)').matches);

    if (stageEl) {
      stageEl.addEventListener('wheel', (e) => {
        if (isStackedLayout()) return;
        e.preventDefault();
      }, { passive: false });

      stageEl.addEventListener('touchmove', (e) => {
        if (isStackedLayout()) return; // 允许页面滚动
        e.preventDefault();
      }, { passive: false });
    }

    // =========================
    // 1) Canvas & 坐标
    // =========================
    const canvas = el('canvas');
    const ctx = canvas.getContext('2d');

    // 世界坐标：t 向右，h 向上
    let world = { tMin: 0, tMax: 12, hMin: 0, hMax: 90 };

    // 绘图区内边距：避免坐标轴/文字贴边，便于看清“落地/下降”
    const PAD = { l: 54, r: 18, t: 22, b: 34 };

    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.width = Math.round(rect.width * dpr);
      canvas.height = Math.round(rect.height * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    window.addEventListener('resize', () => { resizeCanvas(); draw(); });

    function wtToSx(t) {
      const w = canvas.getBoundingClientRect().width;
      const plotW = Math.max(1, w - PAD.l - PAD.r);
      return PAD.l + (t - world.tMin) / (world.tMax - world.tMin) * plotW;
    }

    function whToSy(h) {
      const H = canvas.getBoundingClientRect().height;
      const plotH = Math.max(1, H - PAD.t - PAD.b);
      return PAD.t + (world.hMax - h) / (world.hMax - world.hMin) * plotH;
    }

    // =========================
    // 2) 模型：h(t)=at^2+bt+c
    // =========================
    let A = Number(aEl.value);
    let B = Number(bEl.value);
    let C = Number(cEl.value);
    let HT = Number(HEl.value);
    let speed = Number(spdEl.value);

    function hOf(t) { return A*t*t + B*t + C; }

    function vertex() {
      const tv = -B / (2*A);
      return { t: tv, h: hOf(tv) };
    }

    function rootsForHeight(H) {
      // 解：A t^2 + B t + (C - H) = 0
      const a = A, b = B, c = C - H;
      const delta = b*b - 4*a*c;
      if (delta < 0) return { delta, roots: null };
      const s = Math.sqrt(delta);
      const t1 = (-b - s) / (2*a);
      const t2 = (-b + s) / (2*a);
      const r = (t1 < t2) ? [t1, t2] : [t2, t1];
      return { delta, roots: r };
    }

    function landingTime() {
      // 落地：h(t)=0 的较大正根（用于决定绘图右边界）
      const r = rootsForHeight(0);
      if (!r.roots) return null;
      const pos = r.roots.filter(t => t > 0);
      if (pos.length === 0) return null;
      return Math.max(...pos);
    }

    // =========================
    // 3) 绘制
    // =========================
    let showGrid = true;

    function niceStep(range) {
      const rough = range / 8;
      const pow10 = Math.pow(10, Math.floor(Math.log10(Math.max(rough, 1e-9))));
      const n = rough / pow10;
      let m = 1;
      if (n >= 5) m = 5;
      else if (n >= 2) m = 2;
      else m = 1;
      return m * pow10;
    }

    function drawGridAxes() {
      const w = canvas.getBoundingClientRect().width;
      const H = canvas.getBoundingClientRect().height;

      const x0 = PAD.l, x1 = w - PAD.r;
      const y0 = PAD.t, y1 = H - PAD.b;

      if (showGrid) {
        const tStep = niceStep(world.tMax - world.tMin);
        const hStep = niceStep(world.hMax - world.hMin);

        ctx.save();
        ctx.globalAlpha = 0.35;
        ctx.lineWidth = 1;

        const t0 = Math.ceil(world.tMin / tStep) * tStep;
        for (let t = t0; t <= world.tMax + 1e-9; t += tStep) {
          const sx = wtToSx(t);
          ctx.beginPath();
          ctx.moveTo(sx, y0);
          ctx.lineTo(sx, y1);
          ctx.strokeStyle = 'rgba(255,255,255,0.15)';
          ctx.stroke();
        }

        const h0 = Math.ceil(world.hMin / hStep) * hStep;
        for (let y = h0; y <= world.hMax + 1e-9; y += hStep) {
          const sy = whToSy(y);
          ctx.beginPath();
          ctx.moveTo(x0, sy);
          ctx.lineTo(x1, sy);
          ctx.strokeStyle = 'rgba(255,255,255,0.15)';
          ctx.stroke();
        }

        ctx.restore();
      }

      // t轴：h=0
      ctx.save();
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(255,255,255,0.35)';

      if (world.hMin <= 0 && world.hMax >= 0) {
        const sy0 = whToSy(0);
        ctx.beginPath();
        ctx.moveTo(x0, sy0);
        ctx.lineTo(x1, sy0);
        ctx.stroke();

        ctx.fillStyle = 'rgba(255,255,255,0.70)';
        ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
        ctx.fillText('地面 h=0', x0 + 6, Math.min(y1 - 6, sy0 - 6));
      }

      // 轴标签：放在绘图区边缘，避免与 HUD 打架
      ctx.fillStyle = 'rgba(255,255,255,0.8)';
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
      ctx.fillText('t（时间）→', x1 - 92, y1 + 22);

      ctx.save();
      ctx.translate(x0 - 34, y0 + 100);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText('h（高度）→', 0, 0);
      ctx.restore();

      ctx.restore();
    }

    function drawPoint(t, h, style) {
      const sx = wtToSx(t);
      const sy = whToSy(h);
      ctx.save();
      ctx.fillStyle = style.fill;
      ctx.strokeStyle = style.stroke;
      ctx.lineWidth = style.lineWidth || 2;
      ctx.beginPath();
      ctx.arc(sx, sy, style.r || 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }

    function drawLabel(text, t, h, dx=10, dy=-10) {
      const sx = wtToSx(t);
      const sy = whToSy(h);
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.font = '12px system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans SC", Arial, sans-serif';
      ctx.fillText(text, sx + dx, sy + dy);
      ctx.restore();
    }

    function drawTargetLine() {
      const w = canvas.getBoundingClientRect().width;
      const x0 = PAD.l, x1 = w - PAD.r;
      const sy = whToSy(HT);

      ctx.save();
      ctx.strokeStyle = 'rgba(255,200,120,0.75)';
      ctx.lineWidth = 2;
      ctx.setLineDash([8, 6]);
      ctx.beginPath();
      ctx.moveTo(x0, sy);
      ctx.lineTo(x1, sy);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.fillStyle = 'rgba(255,220,160,0.9)';
      ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
      ctx.fillText(`目标高度 H=${HT.toFixed(0)}`, x0 + 6, Math.max(PAD.t + 14, sy - 8));
      ctx.restore();
    }

    function drawCurve() {
      // 关键：上升段实线，下降段虚线（以顶点为分界）
      const w = canvas.getBoundingClientRect().width;

      const v = vertex();
      const tv = v.t;

      const tLand = landingTime();
      const tEnd = (tLand != null && Number.isFinite(tLand)) ? tLand : world.tMax;

      const tStart = Math.max(world.tMin, 0);
      const tSplit = Math.max(tStart, tv);

      const N = Math.max(320, Math.floor(w / 2));

      ctx.save();
      ctx.lineWidth = 3;

      // 上升段（实线）
      ctx.strokeStyle = 'rgba(199,249,204,0.85)';
      ctx.setLineDash([]);
      ctx.beginPath();
      let started = false;
      for (let i = 0; i <= N; i++) {
        const t = tStart + (i / N) * (tSplit - tStart);
        const y = hOf(t);
        const sx = wtToSx(t);
        const sy = whToSy(y);
        if (!started) { ctx.moveTo(sx, sy); started = true; }
        else ctx.lineTo(sx, sy);
      }
      if (started) ctx.stroke();

      // 下降段（虚线）
      if (tEnd > tSplit + 1e-9) {
        ctx.strokeStyle = 'rgba(199,249,204,0.75)';
        ctx.setLineDash([10, 7]);
        ctx.beginPath();
        started = false;
        for (let i = 0; i <= N; i++) {
          const t = tSplit + (i / N) * (tEnd - tSplit);
          const y = hOf(t);
          const sx = wtToSx(t);
          const sy = whToSy(y);
          if (!started) { ctx.moveTo(sx, sy); started = true; }
          else ctx.lineTo(sx, sy);
        }
        if (started) ctx.stroke();
      }

      ctx.restore();
    }

    function drawHUD() {
      ctx.save();

      const x = PAD.l + 8;
      const y = PAD.t + 18;

      const text = `h(t)（火箭）= ${A.toFixed(2)}t² + ${B.toFixed(1)}t + ${C.toFixed(1)}`;
      ctx.font = '13px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
      const tw = ctx.measureText(text).width;

      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.fillRect(x - 6, y - 14, tw + 12, 20);

      ctx.fillStyle = 'rgba(255,255,255,0.90)';
      ctx.fillText(text, x, y);

      ctx.restore();
    }

    function drawRocket(t) {
      const y = hOf(t);
      const sx = wtToSx(t);
      const sy = whToSy(y);

      // 火箭小三角，方向根据导数 h'(t)=2at+b（仅做视觉）
      const slope = 2*A*t + B;
      const ang = Math.atan2(slope, 1);

      ctx.save();
      ctx.translate(sx, sy);
      ctx.rotate(ang);

      // 身体
      ctx.fillStyle = 'rgba(255,255,255,0.92)';
      ctx.beginPath();
      ctx.moveTo(12, 0);
      ctx.lineTo(-8, -6);
      ctx.lineTo(-5, 0);
      ctx.lineTo(-8, 6);
      ctx.closePath();
      ctx.fill();

      // 火焰
      ctx.fillStyle = 'rgba(255,160,80,0.85)';
      ctx.beginPath();
      ctx.moveTo(-8, 0);
      ctx.lineTo(-14, -4);
      ctx.lineTo(-18, 0);
      ctx.lineTo(-14, 4);
      ctx.closePath();
      ctx.fill();

      ctx.restore();

      drawLabel(`火箭 (t=${t.toFixed(2)}, h=${y.toFixed(2)})`, t, y, 12, -12);
    }

    function drawScene(rocketT=null) {
      const w = canvas.getBoundingClientRect().width;
      const H = canvas.getBoundingClientRect().height;
      ctx.clearRect(0, 0, w, H);

      drawGridAxes();
      drawTargetLine();
      drawCurve();

      // 起点
      drawPoint(0, C, { fill: 'rgba(120,180,255,0.25)', stroke: 'rgba(120,180,255,0.95)', r: 7 });
      drawLabel(`起点 (0, c)=(0, ${C.toFixed(1)})`, 0, C);

      // 顶点
      const v = vertex();
      if (Number.isFinite(v.t) && Number.isFinite(v.h)) {
        drawPoint(v.t, v.h, { fill: 'rgba(180,120,255,0.22)', stroke: 'rgba(200,150,255,0.90)', r: 6 });
        drawLabel(`顶点 (${v.t.toFixed(2)}, ${v.h.toFixed(2)})`, v.t, v.h);
      }

      // 落地点（h=0 的正根，帮助学生理解“下降虚线最终回到地面”）
      const tLand = landingTime();
      if (tLand != null && Number.isFinite(tLand)) {
        drawPoint(tLand, 0, { fill: 'rgba(255,255,255,0.18)', stroke: 'rgba(255,255,255,0.75)', r: 6 });
        drawLabel(`落地 (t=${tLand.toFixed(2)}, 0)`, tLand, 0, -120, -12);
      }

      // 与目标高度的交点
      const hit = rootsForHeight(HT);
      if (hit.roots) {
        const [t1, t2] = hit.roots;
        if (t1 >= 0) {
          drawPoint(t1, HT, { fill: 'rgba(255,220,160,0.25)', stroke: 'rgba(255,220,160,0.90)', r: 6 });
          drawLabel(`上升到达 t1=${t1.toFixed(2)}`, t1, HT, 10, 16);
        }
        if (t2 >= 0) {
          drawPoint(t2, HT, { fill: 'rgba(255,220,160,0.25)', stroke: 'rgba(255,220,160,0.90)', r: 6 });
          drawLabel(`下降回到 t2=${t2.toFixed(2)}`, t2, HT, 10, -10);
        }
      }

      if (rocketT != null) drawRocket(rocketT);

      drawHUD();
    }

    // =========================
    // 4) 状态面板计算
    // =========================
    function fmtSigned(x, digits=2) {
      const s = x.toFixed(digits);
      return (x >= 0 ? '+' : '') + s;
    }

    function updateStatus(msg=null) {
      fnText.textContent = `h(t) = ${A.toFixed(2)}t² ${fmtSigned(B,1)}t ${fmtSigned(C,1)}`;

      const v = vertex();
      vText.textContent = `t_v=${v.t.toFixed(2)},  h_v=${v.h.toFixed(2)}`;

      // 判别式针对 h(t)=H 的方程：A t^2 + B t + (C-HT)=0
      const hit = rootsForHeight(HT);
      const dlt = hit.delta;

      if (dlt < 0) {
        deltaText.textContent = `Δ=${dlt.toFixed(2)} < 0：无解（到不了目标高度）`;
        hitText.textContent = '—';
        aboveText.textContent = '0';
      } else if (Math.abs(dlt) < 1e-9) {
        const t0 = hit.roots ? hit.roots[0] : NaN;
        deltaText.textContent = `Δ≈0：一重解（刚好擦到目标）`;
        hitText.textContent = `t=${t0.toFixed(2)}`;
        aboveText.textContent = '≈0';
      } else {
        const [t1, t2] = hit.roots;
        deltaText.textContent = `Δ=${dlt.toFixed(2)} > 0：两解（上升/下降各一次）`;
        hitText.textContent = `t1=${t1.toFixed(2)},  t2=${t2.toFixed(2)}`;
        const dur = (t2 - t1);
        aboveText.textContent = (dur > 0) ? `${dur.toFixed(2)}` : '0';
      }

      if (msg != null) resText.textContent = msg;
    }

    // =========================
    // 5) 自适应视野
    // =========================
    function clamp(x, lo, hi){ return Math.max(lo, Math.min(hi, x)); }

    function fitWorld() {
      const v = vertex();
      const tLand = landingTime();

      let tMax = 12;
      if (Number.isFinite(v.t)) tMax = Math.max(tMax, v.t + 2);
      if (tLand != null && Number.isFinite(tLand)) tMax = Math.max(tMax, tLand + 1);

      // 也让目标点可见
      const hitH = rootsForHeight(HT);
      if (hitH.roots) {
        tMax = Math.max(tMax, hitH.roots[1] + 1);
      }

      let hMax = Math.max(HT + 15, C + 20);
      if (Number.isFinite(v.h)) hMax = Math.max(hMax, v.h + 15);

      world.tMin = 0;
      world.tMax = clamp(tMax, 8, 30);
      world.hMin = 0;
      world.hMax = clamp(hMax, 40, 200);
    }

    // =========================
    // 6) 动画
    // =========================
    let running = false;
    let tNow = 0;
    let lastTs = null;

    function setButtons() {
      runBtn.disabled = running;
      autoReachBtn.disabled = running;
      toggleGridBtn.disabled = running;
      aEl.disabled = running;
      bEl.disabled = running;
      cEl.disabled = running;
      HEl.disabled = running;
      spdEl.disabled = running;
    }

    function resetSim() {
      running = false;
      tNow = 0;
      lastTs = null;
      setButtons();
      updateStatus('未运行');
      draw();
    }

    function endTimeForAnim() {
      // 动画到：落地时间（h=0 的较大正根），若无则到 world.tMax
      const tLand = landingTime();
      if (tLand != null && Number.isFinite(tLand)) return tLand;
      return world.tMax;
    }

    function step(ts) {
      if (!running) return;
      if (lastTs == null) lastTs = ts;
      const dt = (ts - lastTs) / 1000;
      lastTs = ts;

      const tEnd = endTimeForAnim();

      // 速度：按 t 轴推进
      const base = 2.0; // t 单位/秒
      tNow += dt * base * speed;

      if (tNow >= tEnd) {
        tNow = tEnd;
        running = false;
        setButtons();
        updateStatus('运行结束（已到达曲线末端）');
        drawScene(tNow);
        return;
      }

      drawScene(tNow);
      requestAnimationFrame(step);
    }

    function run() {
      if (running) return;
      resetSim();
      running = true;
      setButtons();
      updateStatus('运行中…');
      lastTs = null;
      requestAnimationFrame(step);
    }

    // =========================
    // 7) UI 交互
    // =========================
    function syncUI() {
      A = Number(aEl.value);
      B = Number(bEl.value);
      C = Number(cEl.value);
      HT = Number(HEl.value);
      speed = Number(spdEl.value);

      aVal.textContent = A.toFixed(2);
      bVal.textContent = B.toFixed(1);
      cVal.textContent = C.toFixed(1);
      hVal.textContent = HT.toFixed(0);
      spdVal.textContent = speed.toFixed(1);

      updateStatus('未运行');
      draw();
    }

    function draw() { drawScene(null); }

    [aEl, bEl, cEl, HEl, spdEl].forEach(inp => {
      inp.addEventListener('input', () => {
        if (running) return;
        syncUI();
      });
    });

    runBtn.addEventListener('click', run);
    resetBtn.addEventListener('click', resetSim);

    // 一键可达：调整 b，使得最高点 h_v >= H（尽量擦边）
    autoReachBtn.addEventListener('click', () => {
      if (running) return;

      // 顶点高度：h_v = c - b^2/(4a) （注意 a<0）
      // 令 h_v = HT，解 b^2 = 4a(c-HT)
      // 因为 a<0，如果 c-HT < 0，那么右边 4a(c-HT) > 0，才有实数解
      const rhs = 4 * A * (C - HT);

      if (rhs <= 0) {
        // 说明即使 b=0，顶点也不够/或者条件不适合，用提高 c 或降低 H 更直观
        updateStatus('⚠ 无法仅靠调 b 让顶点达到 H（可增大 c 或降低 H）');
        draw();
        return;
      }

      const newB = Math.sqrt(rhs); // 取正根（起飞向上）
      const bMin = Number(bEl.min);
      const bMax = Number(bEl.max);
      const clamped = clamp(newB, bMin, bMax);

      bEl.value = String(clamped);
      syncUI();

      // 再给一个判定
      const v = vertex();
      if (v.h + 1e-6 >= HT) updateStatus('✅ 已调整 b：最高点可达目标（擦边/超过）');
      else updateStatus('⚠ 已调整 b，但受滑条范围限制仍不足以到达目标');
      draw();
    });

    toggleGridBtn.addEventListener('click', () => {
      if (running) return;
      showGrid = !showGrid;
      toggleGridBtn.textContent = showGrid ? '网格：开' : '网格：关';
      draw();
    });


    toMenuBtn.addEventListener('click', () => {
      window.location.href = '../index.html';
    });

    // =========================
    // 8) 初始化
    // =========================
    resizeCanvas();
    syncUI();
    resetSim();
  </script>
</body>
</html>